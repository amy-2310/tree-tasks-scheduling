module OptSpaceRecursive
        (spopt_schedule, print_spopt_schedule, spoptnr, toProgram, print_list)
        where
import TopoSort
import Data.List
import Data.Maybe
import Data.Heap (Heap)
import qualified Data.Heap as Heap
import Debug.Trace

--data types for input
type Input_Process = (PId, [Space])
type Input_Program = [Input_Process]

--data types for output
data Operation_out = OP PId OId Space deriving (Show, Eq, Ord)
type Output_State = [Operation_out] --a schedule-state
type Output_Schedule = [(Space, Output_State)]

--data types for tree-like processes converted from input
type Program = [Process]
type Process = [Operation]
type SubProcess = Process
data Operation = Op PId OId Space
                 [Operation] [SubProcess] [Operation] [Operation]
                 deriving (Show,Eq, Ord)
{-
The first list is used to memorize operations in the same state of a schedule. 
When a local schedule is transformed into a linear pseudo-process, each state
of the schedule is transformed into a pseudo-operation memorizing all
operations in that state.
The second list contains the sub-processes generated by the operation (op).
If an op is a local peak in one of the four patterns of standardization, then 
its removed predecessors will be memorized in the third list. These
predecessors will lastly be inserted back into the resulting schedule.
The forth list contains the removed successor of the op...
(analog to the third list).
-}

type PId = Int
type OId = Int
type Space = Int

--------------------------------------------------------------------------------
--the main function and its variant
{-
spopt_schedule calculates a schedule of tree-like processes. 
It takes an input-program and a list of relations (the data type Relation is
declared in module TopoSort). It first calls toProgram to convert the two
arguments into a Program (recursive data type). Then, it calls spoptnr, which
delivers a schedule (in the form of a linear pseudo-process) of the program.
Lastly, it calls revcover, which converts the linear pseudo-process into a
schedule.
-}
spopt_schedule :: Input_Program -> [Relation] -> Output_Schedule
spopt_schedule inputProgram inputRelation =
        recover $ spoptnr $ toProgram inputProgram inputRelation

{-
print_spopt_schedule works almost the same. However, the resulting schedule
will be printed one state per line in ghci.
-}
print_spopt_schedule :: Input_Program -> [Relation] -> IO ()
print_spopt_schedule inputProgram inputRelation =
        print_list $ recover $ spoptnr $ toProgram inputProgram inputRelation
--------------------------------------------------------------------------------
--functions for converting input data
{-
toProgram converts input data into the recursive data type Program.
It first converts all inpue-processes to data type Process and sorts the
relation list by calling the functions toProcess and topo_sort respectively.
Then, it calls the help-function toProgram_h, which goes through the relation
list recursively and inserts sub-processes into a specific operation according
to a relation in each round. Lastly, the resulting process-list (Program) is
sorted by process-id and deliverd.
-}
toProgram :: Input_Program -> [Relation] -> Program 
toProgram ls rs = Heap.sort $ toProgram_h (map toProcess ls) (topo_sort rs)

--toProgram_h inserts sub-processes into specific operations according to relations
toProgram_h:: [Process] -> [Relation] -> Program
toProgram_h ls ((Rel pid oid ps):r_rest)
        = let --find the process with pid in process-list ls
              main_p = fromJust $ find (\p -> (get_pid $ head p) == pid) ls
              
              --find the processes to be inserted into the process with pid in ls
              sub_ps = filter (\p -> elem (get_pid $ head p) ps) ls
              
              --other processes in ls
              other_ps = filter (\p -> (not $ elem (get_pid $ head p) ps) &&
                                       (not $ (get_pid $ head p) == pid)
                                ) ls
              
               --the new process with pid, into which the sub-processes are inserted
              main_p_new = map (\o -> if get_oid o == oid
                                      then add_subps o sub_ps
                                      else o) main_p
              
               --new process-list for the next round
              ls_new = main_p_new:other_ps
          in toProgram_h ls_new r_rest
toProgram_h ls [] = ls

--toProcess converts an Input-Process into a Process
toProcess :: Input_Process -> Process
toProcess (pid,ls) = toProcess_h ls pid 1
toProcess_h (x:xs) pid oid =
        (Op pid oid x [] [] [] []):toProcess_h xs pid (oid+1)
toProcess_h [] _ _ = []

------------------------------------------------------------------------------------------------------------------
--recover schedule
{-
convert a pseudo-process (the result of spoptnr) back into a complete schedule
with space consumption of each state. In a pseudo-process, every op is
transformed from a state in a schedule. Beside that, the removed operations
(from Standardization) have to be inserted back into the schedule.
-}
recover :: Process -> Output_Schedule
recover procs = recover_h procs []

{-
The help-function goes through the pseudo-ops of the pseudo-process recursively.
For every two neiboring pseudo-ops op1 and op2, do the following things:
1. get the memorized state of op1 and insert it into the schedule
2. go through the removed successors of op1. For each successor, a new state
will be calculated and inserted into the schedule.
3. go through the removed predecessors of op2, For each predecessor, a new state
will be calculated and inserted into the schedule.
A new state at step 2. or 3. is calculated as follows:
Let r be the process id of the successor/predecessor, let s be the previously
generated state. Substitute the op having r in state s with the successor/predecessor.
-}

recover_h:: Process -> Output_Schedule -> Output_Schedule

-- pattern-matching: case that there is at least one successor of op1
recover_h (op1@(Op _ _ _ ops1 _ _ after1@(a:as)):op2:rest) schedule
        = let
              --get the memorized state out of op1
              --transform the state into an element of output-schedule 
              --such an element is a tupel (space cunsumption of the state, [ops of the state])
              state = ((foldl (\x y -> (get_space y) + x) 0 ops1),
                       sort $ map op_to_op_out ops1)
              
              --get the successor(s) of op1
              --if the successor is a pseudo-op, get the ops memorized in its first list
              successor = if null (get_ops a) then [a] else get_ops a
              
              --calculate the new state for the successor(s)
              state_recovered =
                sort(
                      (filter (\x -> not $ elem (get_pid x) (map get_pid successor))
                               ops1
                      ) ++ successor
                    )
              
              --op1 for the next round, which has the newly recovered state and 
              --the remaining successors. The pid oid and space is
              --not relevant so just give them a dummy value 0
              op1' = Op 0 0 0 state_recovered [] [] as
                 
          in recover_h (op1':op2:rest) (state:schedule)

--case that there is no successor of op1, but there is at least one predecessor of op2
recover_h (op1@(Op _ _ _ ops1 _ _ []):op2@(Op _ _ _ ops2 _ before2@(b:bs) after2):rest) schedule
        = let 
              state = (foldl (\x y -> get_space y + x) 0 ops1,
                       sort $ map op_to_op_out ops1)
              
              predecessor = if null (get_ops b) then [b] else get_ops b
              
              state_recovered =
                sort (
                        (filter (\x -> not $ elem (get_pid x) (map get_pid predecessor))
                                ops1
                         ) ++ predecessor
                     )
              
              op1' = Op 0 0 0 state_recovered [] [] []
              
              --op2 for the next round, which has the original state and the 
              --remaining predecessors.
              op2' = Op 0 0 0 ops2 [] bs after2
              
          in recover_h (op1':op2':rest) (state:schedule)

--case that there is no successor of op1 and nor predecessor of op2
recover_h (op1@(Op _ _ _ ops1 _ _ []):op2@(Op _ _ _ _ _ [] _):rest) schedule
        = let state = (foldl (\x y -> get_space y + x) 0 ops1,
                       sort $ map op_to_op_out ops1)
          
          --all states between op1 and op2 are recovered
          --check op2 and op3 in the next round
          in recover_h (op2:rest) (state:schedule)

--case that there is only one op in the process:
--this op should not have any successor and should have the last state of
--the schedule. Transform the state and insert it. Done.
recover_h (op@(Op _ _ _ ops1 _ _ _):[]) schedule
        = let state = (foldl (\x y -> get_space y + x) 0 ops1,
                       sort $ map op_to_op_out ops1)
          in reverse (state:schedule)
-------------------------------------------------------------------------------------------------------------------
{-
Firstly, by optimizing n tree-like processes, we get n linear merged processes. (map f procs)
Then, by optimizing the n linear merged processes, we get one merged process. (spoptn_trans)
-}
spoptnr :: [Process] -> Process 
spoptnr procs = spoptn_trans $ map f procs

{-
Calculate the schedule with minimal space consumption of one tree-like process and transform
the schedule into a single process.
The function checks every operation recursively: if an operation generates no sub-processes,
it will not be changed because there is nothing to calculate. If an operation has sub-processes,
the remaining process and the sub-processes will be optimized and transformed into a single process.
Because these processes can also be tree-like, the function has to be applied again on each of them.
-}
f :: Process -> Process
f [] = []
f (op@(Op pid oid sp ops ps front back):rest)
  = --trace (show rest) $
          if null ps then op:f rest --the op does not generate any sub-processes
          else --the op generate at least one sub-process
            if null rest --if the op is the last one of the main-process
            then (Op pid oid sp ops [] front back): (spoptn_trans $ map f ([(Op pid oid sp ops [] front back)]:ps))--the op must runs till the end. The sub-process-list must be emptied so that the break condition can be met.
            else (Op pid oid sp ops [] front back): (spoptn_trans $ map f (rest:ps))
----------------------------------------------------------------------------------------------------------------            
--optimize parallel processes and transform the opimal schedule into a single process
spoptn_trans :: [Process] -> Process
spoptn_trans procs = transform $ snd $ spoptn procs
{-
Transform a schedule into a process. A state in the Schedule is transformed into an operation.
All operations in a state are packed into the first list of the new operation.
The space consumption of the new operation is the sum of space consumption of all operations in the state.
All front-removed and back-removed ops of all ops in a state are pack into the third and forth list of the new op.
The pid and oid of the first operation in the state are used as the pid and oid of the new operation.
-}
--transform a schedule into a process
transform :: [[Operation]] -> Process
transform [] = []
transform (state:rest) = transform_op state : transform rest

--transform a state into a operation
transform_op :: [Operation] -> Operation
transform_op state@((Op pid oid sp ops ps front back):rest)
        = let sp_new = foldl (\x y -> x + (get_space y)) 0 state --add up all the space usages
              ops_new = foldr (\x y -> if null (get_ops x) --if op does not have ops happening at the same time
                                       then (clear_ops_fb x):y
                                       else (map clear_ops_fb $ get_ops x) ++ y) [] state
              front_new = foldr (\x y -> (get_ops_f x) ++ y) [] state
              back_new = foldr (\x y -> (get_ops_b x) ++ y) [] state
          in Op pid oid sp_new ops_new ps front_new back_new
                                                
--------------------------------------------------------------------------------
--Implementation of algorithm SPOPTN
{-
spoptn calculates the minimal space consumption and the corresponding
(incomplete) schedule of parallel processes (a list of linear processes).
First, it standardizes the processes by calling the function standardize. Then,
it heap-sorts the processes twice (from left/right end to global valleys) by
calling the function scan. Based on the results delivered by the two functions,
the minimal space consumption and the corresponding schedule are calculated and
returned.
-}
spoptn :: [Process] -> (Int, [[Operation]])
spoptn ps = let --standardize the processes
                result_std = standardize ps
                
                --take elements out of the result (7-er Tuple) of standardization
                procs_std = fst_7 result_std --stardardized processes
                m_start = snd_7 result_std --sum of space of all start ops
                m_end = forth_7 result_std --sum of space of all end ops
                m_one = sixth_7 result_std --sum of space of all ops in one-op-processes
                ops_one = last_7 result_std --all ops in one-op-processes, they were removed
                starts = third_7 result_std --all start-ops
                ends = fifth_7 result_std --all end-ops
                
                --find global valley of each process
                valleys = searchValleys procs_std
                
                --heap-sort the stardardized processes from left to global valleys
                --and from right to global valleys. The function scan returns a 
                --tupel (space, schedule)
                result_scan_lr = scan procs_std valleys
                result_scan_rl = scan (map reverse procs_std) valleys
                
                --calculate the minimal space consumption of the processes
                spmin = maximum [fst result_scan_lr + m_one,
                                 fst result_scan_rl + m_one,
                                 m_start, m_end]
                
                --merge the two schedules resulted from heap-sort
                schedule = snd result_scan_lr ++ drop 1 (reverse (snd result_scan_rl))
                
                --insert the operations of one-element processes back into schedule
                schedule' = map (++ ops_one) schedule
                
                --insert the removed start peaks and end peaks back into schedule
                --if the first/last state of the schedule is different from the list
                --of all start-/end-ops, it means that some start/end peaks has 
                --been remove. In that case, recover it.
                schedule''= if (sort starts) == (sort $ head schedule')
                            then schedule'
                            else starts:schedule'
                schedule''' = if (sort ends) == (sort $ last schedule'')
                              then schedule''
                              else schedule'' ++ [ends]
             
             in (spmin, schedule''')

----searchValleys and its help-function----
--find the global valley of all processes
searchValleys :: [Process] -> [Operation]
searchValleys ps = map searchValley ps 

--find the global valley of one process
searchValley :: Process -> Operation
searchValley (o:rest) = searchValley_h rest o
searchValley_h [] valley = valley
searchValley_h (o:rest) valley = if get_space o <= get_space valley
                                 then searchValley_h rest o
                                 else searchValley_h rest valley             

----standardize and its help-functions----
{-
The function standardizes a list of linear processes. Output is a 7er-tupel:
(a list of stand. processes, sum of all start ops, the list of all start ops,
sum of all end ops, the list of all end ops, sum of all ops of one-op-processes,
the list of all ops of one-op-processes)
-}
standardize :: [Process] -> ([Process],Int,[Operation],Int,[Operation],Int,[Operation])

standardize procs = standardize_h procs [] 0 [] 0 [] 0 []

{-
The help-function standardize_h goes through the processes recursively.
For each process, it calls the function removeMs to remove operations that match
one of the patterns (M1-M4). It also removes start-peaks, end-peaks and
one-element processes. The sum and composition of start-, end-, and single ops 
are added up through the recursion and are finally returned as output, together
with the standardized processes.
-}
standardize_h (proc:rest) procs_std m_start state_s m_end state_e m_one ops_one
  --if the length of the process retrurned by removeMs is 1, insert nothing into the
  --process-list (remove it). Add up/sum up the start,end,and one operations of
  --this process. Go to the next round.
 |length_proc' == 1
    = standardize_h rest procs_std (m_start + start_sp) (start:state_s)
                                   (m_end + end_sp) (end:state_e)
                                   (m_one + one_sp) (start:ops_one)
 |length_proc' == 2
    = --if the first op is a peak, insert nothing into the result list.
      --the second op becomes single and should be memorized in the list ops_one.
      if start_sp >= end_sp
      then standardize_h rest procs_std (m_start + start_sp) (start:state_s)
                                         (m_end + end_sp) (end:state_e)
                                         (m_one + one_sp) (end:ops_one)
      --if the second op is a peak, insert nothing into the result list.
      --the first op becomes singel and should be memorized in the list ops_one.
      else standardize_h rest procs_std (m_start + start_sp) (start:state_s)
                                         (m_end + end_sp) (end:state_e)
                                         (m_one + one_sp) (start:ops_one)
 --if the length of the process retrurned by removeMs is at least 3
 |otherwise
    = --if both start and end peaks exist
      if start_sp >= sec_sp && end_sp >= vor_end_sp
      then 
           --if length is 3, insert nothing into the result list,
           --because the peaks should be removed and the only left op should also be removed.
           if length proc' == 3
           then standardize_h rest procs_std
                               (m_start + start_sp) (start:state_s)
                               (m_end + end_sp) (end:state_e)
                               (m_one + one_sp) (sec:ops_one)
           --if length > 3, insert the process without start and end peaks
           --into the result list
           else standardize_h rest ((drop 1 $ init proc'):procs_std)
                               (m_start + start_sp) (start:state_s)
                               (m_end + end_sp) (end:state_e)
                               (m_one + one_sp) (ops_one)
      else
         --if only start peak exists, insert the process returned by removeMs
         --without start peak into the result list
        if start_sp >= sec_sp
        then standardize_h rest ((drop 1 proc'):procs_std)
                                 (m_start + start_sp) (start:state_s)
                                 (m_end + end_sp) (end:state_e)
                                 (m_one + one_sp) (ops_one)
        else
          --if only end peak exists, insert the process returned by removeMs
          --without end peak into the result list
          if end_sp >= vor_end_sp
          then standardize_h rest ((init proc'):procs_std)
                                   (m_start + start_sp) (start:state_s)
                                   (m_end + end_sp) (end:state_e)
                                   (m_one + one_sp) (ops_one)
          --if no start or end peaks exist, insert the process returned by removeMs
          --into the result list
          else standardize_h rest (proc':procs_std)
                                   (m_start + start_sp) (start:state_s)
                                   (m_end + end_sp) (end:state_e)
                                   (m_one + one_sp) (ops_one)
   where
        proc' = removeMs proc ----remove operations matching M1-M4 in the process
        length_proc' = length proc' 
        start = head proc' --start op
        start_sp = get_space start --space consumption of start op 
        sec = head $ drop 1 proc'--second op
        sec_sp = get_space sec --space consumption of the second op
        end = last proc' --end op
        end_sp = get_space end --space consumption of end op
        vor_end = last $ init proc' --second last op
        vor_end_sp = get_space vor_end --space consumption of the second last op
        --space consumption of a single op
        one_sp | length_proc' == 1 = start_sp
               | length_proc' == 2 = min start_sp end_sp --the higher one will be removed
               | otherwise = 0 --no single op

--break condition: when no process left to be standardized           
standardize_h [] proc_std m_start state_s m_end state_e m_one ops_one
        = (reverse proc_std, m_start, reverse state_s, m_end, reverse state_e,
           m_one, reverse ops_one)

--removeMs removes patterns M1-M4 in a process
removeMs :: Process -> Process
removeMs = removeMs_h []

{-
The help-function removeMs_h go through the operations of a process recursively.
In each round, it checks if the first four operations match any of the patterns
M1-M4. If that is the case, the operations are removed from the process and
memorized in the peak-op of the pattern. 
-}
removeMs_h :: Process -> Process -> Process
removeMs_h p_new p_old@(oi:oi1:oi2:oi3:rest)
        | matchM1 oi oi1 oi2 = removeMs_h p_new' p_old_matchM1
        | matchM2 oi oi1 oi2 = removeMs_h p_new' p_old_matchM2
        | matchM3 oi oi1 oi2 oi3 = removeMs_h p_new' p_old_matchM3
        | matchM4 oi oi1 oi2 oi3 = removeMs_h p_new' p_old_matchM4
        | otherwise = removeMs_h (oi:p_new) (oi1:oi2:oi3:rest) 
         where
         --calculate the new arguments for the next round. Since some ops might
         --have been removed, new patterns might appear. Therefor the scaning
         --has to continue at the position oi-2.
         p_new' = drop 2 p_new
         ops_return = reverse $ take 2 p_new
         --oi >= oi1 >= oi2
         p_old_matchM1 = let --get oi1's predecessor, oi1 it self, and its successors
                             ops_toAdd = get_ops_f oi1 ++ [clear_ops_fb oi1]
                                         ++ get_ops_b oi1
                             
                             --let oi memorize the above operations as its successors
                             oi' = add_ops_b oi ops_toAdd
                         in ops_return ++ (oi':oi2:oi3:rest)
         
         --oi <= oi1 <= oi2
         p_old_matchM2 = let ops_toAdd = get_ops_f oi1 ++ [clear_ops_fb oi1]
                                         ++ get_ops_b oi1
                             
                             --let oi2 memorize the above operations as its predecessors
                             oi2' = add_ops_f oi2 ops_toAdd
                         in ops_return ++ (oi:oi2':oi3:rest)
         
         --oi is the peak in pattern M3
         p_old_matchM3 = let --get oi1's predecessor, oi1 itself, and its successors,
                             --oi2's prdecessor, oi2 itself, and its successors
                             ops_toAdd = get_ops_f oi1 ++ [clear_ops_fb oi1]
                                         ++ get_ops_b oi1 ++ get_ops_f oi2
                                         ++ [clear_ops_fb oi2] ++ get_ops_b oi2
                             
                             --let oi memorize the above operations as its successors
                             oi' = add_ops_b oi ops_toAdd
                         in ops_return ++ (oi':oi3:rest)
         
         --oi3 is the peak in pattern M4                
         p_old_matchM4 = let ops_toAdd = get_ops_f oi1 ++ [clear_ops_fb oi1]
                                         ++ get_ops_b oi1 ++ get_ops_f oi2
                                         ++ [clear_ops_fb oi2] ++ get_ops_b oi2
                             
                             --let oi3 memorize the above operations as its predecessors
                             oi3' = add_ops_f oi3 ops_toAdd
                         in ops_return ++ (oi:oi3':rest)

--case that there are only three operations left to be checked.
removeMs_h p_new p_old@[oi,oi1,oi2]
        | matchM1 oi oi1 oi2 = removeMs_h p_new' p_old_matchM1
        | matchM2 oi oi1 oi2 = removeMs_h p_new' p_old_matchM2
        | otherwise = removeMs_h (oi:p_new) [oi1,oi2]
        where
         p_new' = (drop 2 p_new)
         ops_return = reverse $ take 2 p_new
         p_old_matchM1 = let ops_toAdd = get_ops_f oi1 ++ [clear_ops_fb oi1]
                                         ++ get_ops_b oi1
                             oi' = add_ops_b oi ops_toAdd
                         in ops_return ++ [oi',oi2]
         p_old_matchM2 = let ops_toAdd = get_ops_f oi1 ++ [clear_ops_fb oi1]
                                         ++ get_ops_b oi1
                             oi2' = add_ops_f oi2 ops_toAdd
                         in ops_return ++ [oi,oi2']

--Break condition: there are less than three ops to be checked. No pattern can occur.
removeMs_h p_new p_old = (reverse p_new) ++ p_old

--help-functions for removeMs_h. Each checks if the operations in the arguments
-- match specific pattern and returns a bool.
matchM1 (Op _ _ sp1 _ _ _ _) (Op _ _ sp2 _ _ _ _)(Op _ _ sp3 _ _ _ _)
        = (sp1 >= sp2 && sp2 >= sp3)
        
matchM2 (Op _ _ sp1 _ _ _ _) (Op _ _ sp2 _ _ _ _)(Op _ _ sp3 _ _ _ _)
        = (sp1 <= sp2 && sp2 <= sp3)

matchM3 (Op _ _ sp1 _ _ _ _) (Op _ _ sp2 _ _ _ _)
        (Op _ _ sp3 _ _ _ _) (Op _ _ sp4 _ _ _ _)
        = (sp1 > sp2 && sp2 < sp3 && sp3 > sp4 && sp1 >= sp3 && sp2 >= sp4)

matchM4 (Op _ _ sp1 _ _ _ _) (Op _ _ sp2 _ _ _ _)
        (Op _ _ sp3 _ _ _ _) (Op _ _ sp4 _ _ _ _)
        = (sp1 < sp2 && sp2 > sp3 && sp3 < sp4 && sp1 <= sp3 && sp2 <= sp4)

----scan and its help-functions----
{-
The function scan heap-sorts operations (before the global valley) of
standardized processes by space increase between two neighboring operations
(a loacl valley and a local peak). It returns a tuple, which contains the minimal
space consumption of executing the processes and the corresponding schedul.
-}
scan:: [Process] -> [Operation]-> (Int, [[Operation]])  --(spmin, schedule)
scan procs valleys = let --initiate the heap
                         heap = toHeap procs
                         
                         --space of current state, which equals to the sum of space
                         --of the first op of all processes
                         s =  foldl (\x y -> x + (get_space $ head y)) 0 procs
                         
                         --peak space consumption of the schedule
                         m = s
                         
                         --first state of the schedule, which consists of first
                         --op of all processes
                         first_state = map head procs
                         
                     in scan_h heap procs valleys s m [first_state]

{-help-function of scan. In each round, the min-element of the heap is omitted.
The corresponding process propagates by two operations (two states will be inserted
into the schedule; the space increase of the next two ops will be inserted into the
heap), if its global valley has not been met. The peak space of the schedule is
memorized during the recursion. The recursion stops, when the heap becomes empty
(all global valleys has been met).
--arguments: heap, processes, global valleys, space of current state, max. space
             ,schedule
--output: (max. Space, schedule)
-}
scan_h :: [(Int,Int)] -> [Process] -> [Operation] -> Int -> Int -> [[Operation]]
          -> (Int, [[Operation]])

scan_h (h:rest) procs valleys s m schedule
        = let --get the process id and space increase of the min-element of heap
              index_h = snd h 
              dist_h = fst h
              
              --get the process having the process id
              selected_proc = procs!!index_h
              
              --space usage and max. sapce usage for the next round
              s_new = if (not isGlobalValley)
                      then s + (get_space (selected_proc !! 2)
                             - get_space (selected_proc !! 0))
                      else s
              m_new = if (not isGlobalValley)
                      then max m (s + dist_h)
                      else m
              
              --processes for the next round. Only the process having the process
              --id might propagate (if its global valley has not been visited.
              procs' = map (\x -> if ((procs !! index_h) == x)
                                     && (not isGlobalValley)
                                  then drop 2 x else x) procs
              
              --The two operations of the min-element
              selected_ops = [selected_proc !! 2,selected_proc !! 1]
              
              --whether the global valley of the process having the process id is met
              isGlobalValley = valleys !! index_h `elem`
                               [selected_proc !! 0,selected_proc !! 1]
              
              --The first element of other processes
              ops_not_changed = [map head $ filter (\x -> procs!!index_h /= x) procs]
              
              --generate two states for schedule
              states = [Heap.sort(p:ps) | p <- selected_ops, ps <- ops_not_changed]
              
              --insert the states into the schedule, if the global vally of the 
              --propagating process has not been visted
              schedule_new = if not isGlobalValley
                             then states ++ schedule
                             else schedule
              
              --heap for the next round. If there are enough operations in the
              --propagating process and if the global valley has not been met,
              --insert a new element, which contains the space increase of the next
              --two operations of the process, into the heap and sort it.
              --If that is not the case, let the new heap be the old heap without
              --the min-element. 
              heap_new = if (length selected_proc >= 4) && (not isGlobalValley)
                         then let elem_new = ((get_space(selected_proc!!3)
                                             - get_space(selected_proc!!2)), index_h)
                              in Heap.sort $ elem_new:rest
                         else rest
          in scan_h heap_new procs' valleys s_new m_new schedule_new

--Break condition: the heap became empty. The schedule is complete.
scan_h [] procs valleys s m schedule = (m, reverse schedule)
         
{-
toHeap inserts the space increase of the first and second operations of all
processes into a list recursively and heap-sorts it.
-}
toHeap :: [Process] -> [(Int,Int)]
toHeap = Heap.sort . toHeap_h 0

toHeap_h :: Int -> [Process] -> [(Int,Int)]
toHeap_h _ [] = []
toHeap_h index (p:rest)=
        ((get_space (p!!1) - get_space (p!!0)),index):toHeap_h (index+1) rest
------------------------------------------------------------------------------------------------------------------
--some basic functions

--functions for data type Operation
get_pid (Op pid _ _ _ _ _ _) = pid
get_oid (Op _ oid _ _ _ _ _) = oid
get_space (Op _ _ sp _ _ _ _) = sp
get_ops (Op _ _ _ ops _ _ _) = ops
get_subps (Op _ _ _ _ subps _ _) = subps
get_ops_f (Op _ _ _ _ _ ops_f _) = ops_f
get_ops_b (Op _ _ _ _ _ _ ops_b) = ops_b
add_subps (Op pid oid sp ops subps front back) subps' = (Op pid oid sp ops (subps ++ subps') front back)
add_ops_f (Op pid oid sp ops ps ops_f ops_b) ops_f_toAdd = (Op pid oid sp ops ps (ops_f_toAdd ++ ops_f) ops_b)
add_ops_b (Op pid oid sp ops ps ops_f ops_b) ops_b_toAdd = (Op pid oid sp ops ps ops_f (ops_b ++ ops_b_toAdd))
clear_ops_fb (Op pid oid sp ops ps ops_f ops_b) = (Op pid oid sp ops ps [] [])

--get-functions for 7er-tupel
fst_7 (x,_,_,_,_,_,_) = x
snd_7 (_,x,_,_,_,_,_) = x
third_7 (_,_,x,_,_,_,_) = x
forth_7 (_,_,_,x,_,_,_) = x
fifth_7 (_,_,_,_,x,_,_) = x
sixth_7 (_,_,_,_,_,x,_) = x
last_7 (_,_,_,_,_,_,x) = x
--convert Operation to Operation_out
op_to_op_out (Op pid oid sp _ _ _ _) = OP pid oid sp

--print a list of anything that can be showed
print_list list = putStrLn $ toString_list list 
toString_list [] = ""
toString_list (x:rest) = (show x) ++ "\n\n" ++ toString_list rest
-----------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------                 
p5 = [(1,[2,8,4,16,1]),(2,[5,1,2]),(3,[8,2,2,1]),(4,[5,1,9,2,1]),(5,[8,8,1]),(6,[3,1,3])]
r5 = [(Rel 1 2 [2,3]),(Rel 4 1 [5]),(Rel 2 2 [6])]                        
test_p5 = print_spopt_schedule p5 r5

--subtree under op 2 2
p5_sub_22 = [(1,[2]),(6,[3,1,3])]
test_p5_sub_22 = print_spopt_schedule p5_sub_22 []
--optimum = 5, space = [5,3,5]

--subtree under op 1 2
p5_sub_12 = [(2,[5,1,5,3,5]), (1,[4,16,1]), (3,[8,2,2,1])]
test_p5_sub_12 = print_spopt_schedule p5_sub_12 []
--opt = 18, space = [17,11,11,6,18,3,7,5,7]

--subtree under op 4 1
p5_sub_41 =  [(4,[1,9,2,1]),(5,[8,8,1])]
test_p5_sub_41 = print_spopt_schedule p5_sub_41 []
--opt = 10, space = [9,9,2,10,3,2]

--optimize two main processes p1 and p4
p5_mp_14 = [(1,[2,8,17,11,11,6,18,3,7,5,7]),(4,[5,9,9,2,10,3,2])]
test_p5_mp_14 = print_spopt_schedule p5_mp_14 []
--opt = 20
------------------------------------------------------------------------------------------------
p6_s1 = [(1,[2,6,5,2,4]),(2,[3,1])]
test_p6_s1 = print_spopt_schedule p6_s1 []

p6 = [(1,[2,5,4,1]),(2,[1,3]),(3,[3,1])]
r6 = [Rel 1 1 [2]]
test_p6 = print_spopt_schedule p6 r6
-----------------------------------------------

p:: [(Int, [Int])]
p = [(1,[1,3,2,3]),(2,[3]),(3,[2,3,1]),(4,[3,1]),(5,[1,5,4])]
r = [Rel 4 1 [3],Rel 5 1 [2],Rel 5 2 [1,4]]

p1::[(Int,[Int])]
p1 = [(1,[1,2]),(2,[3,4]),(3,[5,6,5])]
r1 = [Rel 1 1 [2],Rel 2 1 [3]]    

p1_t1::[(Int,[Int])]
p1_t1 = [(2,[4]),(3,[5,6,5])]
