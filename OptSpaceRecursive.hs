module OptSpaceRecursive
        (spopt_schedule, print_spopt_schedule, print_list, Input_Process)
        where
import TopoSort
import Data.List
import Data.Maybe
import Data.Heap (Heap)
import qualified Data.Heap as Heap

--data types for input
type Input_Process = (PId, [Space])
type Input_Program = [Input_Process]

--data types for output
data Operation_out = OP PId OId Space deriving (Show, Eq, Ord)
type Output_State = [Operation_out] --a schedule-state
type Output_Schedule = [(Space, Output_State)]

--data types for tree-like processes converted from input
type Program = [Process]
type Process = [Operation]
type SubProcess = Process
data Operation = Op PId OId Space
                 [Operation] [SubProcess] [Predecessor] [Successor]
                 deriving (Show,Eq, Ord)
{-
The first list is used to memorize operations in the same state of a schedule. 
When a local schedule is transformed into a linear pseudo-process, each state
of the schedule is transformed into a pseudo-operation memorizing all
operations in that state.
The second list contains the sub-processes generated by the operation (op).
If an op is a local peak in one of the four patterns of standardization, then 
its removed predecessors will be memorized in the third list. These
predecessors will lastly be inserted back into the resulting schedule.
The forth list contains the removed successor of the op...
(analog to the third list).
-}

type PId = Int
type OId = Int
type Space = Int
type Predecessor = Operation
type Successor = Operation

--------------------------------------------------------------------------------
--the main function and its variant
{-
spopt_schedule calculates a schedule of tree-like processes. 
It takes an input-program and a list of relations (the data type Relation is
declared in module TopoSort). It first calls toProgram to convert the two
arguments into a Program (recursive data type). Then, it calls spoptnr, which
delivers a schedule (in the form of a linear pseudo-process) of the program.
Lastly, it calls revcover, which converts the linear pseudo-process into a
schedule.
-}
spopt_schedule :: Input_Program -> [Relation] -> Output_Schedule
spopt_schedule inputProgram inputRelation =
        recover $ spoptnr $ toProgram inputProgram inputRelation

{-
print_spopt_schedule works almost the same. However, the resulting schedule
will be printed one state per line in ghci.
-}
print_spopt_schedule :: Input_Program -> [Relation] -> IO ()
print_spopt_schedule inputProgram inputRelation =
        print_list $ recover $ spoptnr $ toProgram inputProgram inputRelation
--------------------------------------------------------------------------------
--functions for converting input data
{-
toProgram converts input data into the recursive data type Program.
It first converts all inpue-processes to data type Process and sorts the
relation list by calling the functions toProcess and topo_sort respectively.
Then, it calls the help-function toProgram_h, which goes through the relation
list recursively and inserts sub-processes into a specific operation according
to a relation in each round. Lastly, the resulting process-list (Program) is
sorted by process-id and deliverd.
-}
toProgram :: Input_Program -> [Relation] -> Program 
toProgram ls rs = Heap.sort $ toProgram_h (map toProcess ls) (topo_sort rs)

--toProgram_h inserts sub-processes into specific operations according to relations
toProgram_h:: [Process] -> [Relation] -> Program
toProgram_h ls ((Rel pid oid ps):r_rest)
        = let --find the process with pid in process-list ls
              main_p = fromJust $ find (\p -> (getPid $ head p) == pid) ls
              
              --find the processes to be inserted into the process with pid in ls
              sub_ps = filter (\p -> elem (getPid $ head p) ps) ls
              
              --other processes in ls
              other_ps = filter (\p -> (not $ elem (getPid $ head p) ps) &&
                                       (not $ (getPid $ head p) == pid)
                                ) ls
              
               --the new process with pid, into which the sub-processes are inserted
              main_p_new = map (\o -> if getOid o == oid
                                      then addSubPs o sub_ps
                                      else o) main_p
              
               --new process-list for the next round
              ls_new = main_p_new:other_ps
          in toProgram_h ls_new r_rest
toProgram_h ls [] = ls

--toProcess converts an Input-Process into a Process
toProcess :: Input_Process -> Process
toProcess (pid,ls) = toProcess_h ls pid 1
toProcess_h (x:xs) pid oid =
        (Op pid oid x [] [] [] []):toProcess_h xs pid (oid+1)
toProcess_h [] _ _ = []

------------------------------------------------------------------------------------------------------------------
--recover schedule
{-
convert a pseudo-process (the result of spoptnr) back into a complete schedule
with space consumption of each state. In a pseudo-process, every op is
transformed from a state in a schedule. Beside that, the removed operations
(from Standardization) have to be inserted back into the schedule.
-}
recover :: Process -> Output_Schedule
recover procs = recover_h procs []

{-
The help-function goes through the pseudo-ops of the pseudo-process recursively.
For every two neiboring pseudo-ops op1 and op2, do the following things:
1. get the memorized state of op1 and insert it into the schedule
2. go through the removed successors of op1. For each successor, a new state
will be calculated and inserted into the schedule.
3. go through the removed predecessors of op2, For each predecessor, a new state
will be calculated and inserted into the schedule.
A new state at step 2. or 3. is calculated as follows:
Let r be the process id of the successor/predecessor, let s be the previously
generated state. Substitute the op having r in state s with the successor/predecessor.
-}

recover_h:: Process -> Output_Schedule -> Output_Schedule

-- pattern-matching: case that there is at least one successor of op1
recover_h (op1@(Op _ _ _ ops1 _ _ after1@(a:as)):op2:rest) schedule
        = let
              --get the memorized state out of op1
              --transform the state into an element of output-schedule 
              --such an element is a tupel (space cunsumption of the state, [ops of the state])
              state = ((foldl (\x y -> (getSpace y) + x) 0 ops1),
                       sort $ map toOpOut ops1)
              
              --get the successor(s) of op1
              --if the successor is a pseudo-op, get the ops memorized in its first list
              successor = if null (getOps a) then [a] else getOps a
              
              --calculate the new state for the successor(s)
              state_recovered =
                sort(
                      (filter (\x -> not $ elem (getPid x) (map getPid successor))
                               ops1
                      ) ++ successor
                    )
              
              --op1 for the next round, which has the newly recovered state and 
              --the remaining successors. The pid oid and space is
              --not relevant so just give them a dummy value 0
              op1' = Op 0 0 0 state_recovered [] [] as
                 
          in recover_h (op1':op2:rest) (state:schedule)

--case that there is no successor of op1, but there is at least one predecessor of op2
recover_h (op1@(Op _ _ _ ops1 _ _ []):op2@(Op _ _ _ ops2 _ before2@(b:bs) after2):rest) schedule
        = let 
              state = (foldl (\x y -> getSpace y + x) 0 ops1,
                       sort $ map toOpOut ops1)
              
              predecessor = if null (getOps b) then [b] else getOps b
              
              state_recovered =
                sort (
                        (filter (\x -> not $ elem (getPid x) (map getPid predecessor))
                                ops1
                         ) ++ predecessor
                     )
              
              op1' = Op 0 0 0 state_recovered [] [] []
              
              --op2 for the next round, which has the original state and the 
              --remaining predecessors.
              op2' = Op 0 0 0 ops2 [] bs after2
              
          in recover_h (op1':op2':rest) (state:schedule)

--case that there is no successor of op1 and nor predecessor of op2
recover_h (op1@(Op _ _ _ ops1 _ _ []):op2@(Op _ _ _ _ _ [] _):rest) schedule
        = let state = (foldl (\x y -> getSpace y + x) 0 ops1,
                       sort $ map toOpOut ops1)
          
          --all states between op1 and op2 are recovered
          --check op2 and op3 in the next round
          in recover_h (op2:rest) (state:schedule)

--case that there is only one op in the process:
--this op should not have any successor and should have the last state of
--the schedule. Transform the state and insert it. Done.
recover_h (op@(Op _ _ _ ops1 _ _ _):[]) schedule
        = let state = (foldl (\x y -> getSpace y + x) 0 ops1,
                       sort $ map toOpOut ops1)
          in reverse (state:schedule)

--help-function. Convert data type Operation to Operation_out
toOpOut (Op pid oid sp _ _ _ _) = OP pid oid sp
-------------------------------------------------------------------------------------------------------------------
{-
spoptnr optimizes tree-like processes and returned a pseudo-process.
First, by optimizing n tree-like processes, we get n linear pseudo-processes. (map f procs)
Then, by optimizing the n linear pseudo-processes, we get one pseudo-process. (spoptn_trans)
-}
spoptnr :: [Process] -> Process 
spoptnr procs = spoptn_trans $ map f procs

{-
f is a help-function of spoptnr. It optimizes one tree-like process and returned
a pseudo-process. It goes through the operations of the tree-like process recursively.
For each op, if it generates no sub-process, it will not be changed. Otherwise,
the remaining ops (is also a process) and the sub-processes will together be
optimized by spoptn_trans. However, since these processes can also have forks,
the function has to be appleid again to each of them.
-}
f :: Process -> Process
f [] = []
f (op@(Op pid oid sp ops ps front back):rest) = 
    if null ps --if the op does not generate any sub-process
    then op:f rest --call itself to optimize the tree below
    else
        if null rest --if the op is the last op of the process (special case)
        then (Op pid oid sp ops [] front back):
                (spoptn_trans $ map f ([(Op pid oid sp ops [] front back)]:ps))
                --the op must run till the end.
                --the sub-process-list must be emptied so that the break condition can be met.
        
        else (Op pid oid sp ops [] front back): (spoptn_trans $ map f (rest:ps))
----------------------------------------------------------------------------------------------------------------            
{-
spoptn_trans is an extention to SPOPTN. It calls spoptn to optimize linear
processes and then transforms the resulting space-optimal schedule into a
pseudo-process.
-}
spoptn_trans :: [Process] -> Process
spoptn_trans procs = transform $ snd $ spoptn procs

{-
transform is a help-function of spoptn_trans. It transforms a schedule into a
pseudo-process. Each state of the schedule is transformed into an pseudo-op:
all ops of the state are packed into the first list of the pseudo-op. If an op is
already a pseudo-op, its component-ops in its first list are also backed into the
first list of the new pseudo-op.
The space consumption of the pseudo-op is the sum of space of all ops
in the state.
All predecessors and successors of all ops in the state are pack into the third
and forth list of the pseudo-op respectively.
The pid and oid of the first op in the state are used as the pid and oid of the
pseudo-op.
-}
--transform a schedule into a pseudo-process
transform :: [[Operation]] -> Process
transform [] = []
transform (state:rest) = transform_op state : transform rest

--transform a state into a pseudo-op
transform_op :: [Operation] -> Operation
transform_op state@((Op pid oid sp ops ps front back):rest)
        = let --add up the space of all ops of the state
              sp_new = foldl (\x y -> x + (getSpace y)) 0 state
              
              --generate the first list of the pseudo-op: if an op of the state
              --is not a pseudo-op, clear its successor- and predecessor-lists and
              --insert it into ops_new. If an op is pseudo, get the ops in its
              --first list, clear their successor- and predecessor-lists, and insert
              --them together with the op into ops_new.
              ops_new = foldr (\x y ->
                              if null (getOps x)
                              then (clearPredSucc x):y
                              else (map clearPredSucc $ getOps x) ++ y) [] state
              
              --generate the predecessor-list of pseudo-op
              front_new = foldr (\x y -> (getPred x) ++ y) [] state
              
              --generate the successor-list of pseudo-op
              back_new = foldr (\x y -> (getSucc x) ++ y) [] state
              
          in Op pid oid sp_new ops_new ps front_new back_new --pseudo-op
                                                
--------------------------------------------------------------------------------
--Implementation of algorithm SPOPTN
{-
spoptn calculates the minimal space consumption and the corresponding
(incomplete) schedule of parallel processes (a list of linear processes).
First, it standardizes the processes by calling the function standardize. Then,
it heap-sorts the processes twice (from left/right end to global valleys) by
calling the function scan. Based on the results delivered by the two functions,
the minimal space consumption and the corresponding schedule are calculated and
returned.
-}
spoptn :: [Process] -> (Int, [[Operation]])
spoptn ps = let --standardize the processes
                result_std = standardize ps
                
                --take elements out of the result (7-er Tuple) of standardization
                procs_std = fst_7 result_std --stardardized processes
                m_start = snd_7 result_std --sum of space of all start ops
                m_end = forth_7 result_std --sum of space of all end ops
                m_one = sixth_7 result_std --sum of space of all ops in one-op-processes
                ops_one = last_7 result_std --all ops in one-op-processes, they were removed
                starts = third_7 result_std --all start-ops
                ends = fifth_7 result_std --all end-ops
                
                --find global valley of each process
                valleys = searchValleys procs_std
                
                --heap-sort the stardardized processes from left to global valleys
                --and from right to global valleys. The function scan returns a 
                --tupel (space, schedule)
                result_scan_lr = scan procs_std valleys
                result_scan_rl = scan (map reverse procs_std) valleys
                
                --calculate the minimal space consumption of the processes
                spmin = maximum [fst result_scan_lr + m_one,
                                 fst result_scan_rl + m_one,
                                 m_start, m_end]
                
                --merge the two schedules resulted from heap-sort
                schedule = snd result_scan_lr ++ drop 1 (reverse (snd result_scan_rl))
                
                --insert the operations of one-element processes back into schedule
                schedule' = map (++ ops_one) schedule
                
                --insert the removed start peaks and end peaks back into schedule
                --if the first/last state of the schedule is different from the list
                --of all start-/end-ops, it means that some start/end peaks has 
                --been remove. In that case, recover it.
                schedule''= if (sort starts) == (sort $ head schedule')
                            then schedule'
                            else starts:schedule'
                schedule''' = if (sort ends) == (sort $ last schedule'')
                              then schedule''
                              else schedule'' ++ [ends]
             
             in (spmin, schedule''')

----searchValleys and its help-function----
--find the global valley of all processes
searchValleys :: [Process] -> [Operation]
searchValleys ps = map searchValley ps 

--find the global valley of one process
searchValley :: Process -> Operation
searchValley (o:rest) = searchValley_h rest o
searchValley_h [] valley = valley
searchValley_h (o:rest) valley = if getSpace o <= getSpace valley
                                 then searchValley_h rest o
                                 else searchValley_h rest valley             

----standardize and its help-functions----
{-
The function standardizes a list of linear processes. Output is a 7er-tupel:
(a list of stand. processes, sum of all start ops, the list of all start ops,
sum of all end ops, the list of all end ops, sum of all ops of one-op-processes,
the list of all ops of one-op-processes)
-}
standardize :: [Process] -> ([Process],Int,[Operation],Int,[Operation],Int,[Operation])

standardize procs = standardize_h procs [] 0 [] 0 [] 0 []

{-
The help-function standardize_h goes through the processes recursively.
For each process, it calls the function removeMs to remove operations that match
one of the patterns (M1-M4). It also removes start-peaks, end-peaks and
one-element processes. The sum and composition of start-, end-, and single ops 
are added up through the recursion and are finally returned as output, together
with the standardized processes.
-}
standardize_h (proc:rest) procs_std m_start state_s m_end state_e m_one ops_one
  --if the length of the process retrurned by removeMs is 1, insert nothing into the
  --process-list (remove it). Add up/sum up the start,end,and one operations of
  --this process. Go to the next round.
 |length_proc' == 1
    = standardize_h rest procs_std (m_start + start_sp) (start:state_s)
                                   (m_end + end_sp) (end:state_e)
                                   (m_one + one_sp) (start:ops_one)
 |length_proc' == 2
    = --if the first op is a peak, insert nothing into the result list.
      --the second op becomes single and should be memorized in the list ops_one.
      if start_sp >= end_sp
      then standardize_h rest procs_std (m_start + start_sp) (start:state_s)
                                         (m_end + end_sp) (end:state_e)
                                         (m_one + one_sp) (end:ops_one)
      --if the second op is a peak, insert nothing into the result list.
      --the first op becomes singel and should be memorized in the list ops_one.
      else standardize_h rest procs_std (m_start + start_sp) (start:state_s)
                                         (m_end + end_sp) (end:state_e)
                                         (m_one + one_sp) (start:ops_one)
 --if the length of the process retrurned by removeMs is at least 3
 |otherwise
    = --if both start and end peaks exist
      if start_sp >= sec_sp && end_sp >= vor_end_sp
      then 
           --if length is 3, insert nothing into the result list,
           --because the peaks should be removed and the only left op should also be removed.
           if length proc' == 3
           then standardize_h rest procs_std
                               (m_start + start_sp) (start:state_s)
                               (m_end + end_sp) (end:state_e)
                               (m_one + one_sp) (sec:ops_one)
           --if length > 3, insert the process without start and end peaks
           --into the result list
           else standardize_h rest ((drop 1 $ init proc'):procs_std)
                               (m_start + start_sp) (start:state_s)
                               (m_end + end_sp) (end:state_e)
                               (m_one + one_sp) (ops_one)
      else
         --if only start peak exists, insert the process returned by removeMs
         --without start peak into the result list
        if start_sp >= sec_sp
        then standardize_h rest ((drop 1 proc'):procs_std)
                                 (m_start + start_sp) (start:state_s)
                                 (m_end + end_sp) (end:state_e)
                                 (m_one + one_sp) (ops_one)
        else
          --if only end peak exists, insert the process returned by removeMs
          --without end peak into the result list
          if end_sp >= vor_end_sp
          then standardize_h rest ((init proc'):procs_std)
                                   (m_start + start_sp) (start:state_s)
                                   (m_end + end_sp) (end:state_e)
                                   (m_one + one_sp) (ops_one)
          --if no start or end peaks exist, insert the process returned by removeMs
          --into the result list
          else standardize_h rest (proc':procs_std)
                                   (m_start + start_sp) (start:state_s)
                                   (m_end + end_sp) (end:state_e)
                                   (m_one + one_sp) (ops_one)
   where
        proc' = removeMs proc ----remove operations matching M1-M4 in the process
        length_proc' = length proc' 
        start = head proc' --start op
        start_sp = getSpace start --space consumption of start op 
        sec = head $ drop 1 proc'--second op
        sec_sp = getSpace sec --space consumption of the second op
        end = last proc' --end op
        end_sp = getSpace end --space consumption of end op
        vor_end = last $ init proc' --second last op
        vor_end_sp = getSpace vor_end --space consumption of the second last op
        --space consumption of a single op
        one_sp | length_proc' == 1 = start_sp
               | length_proc' == 2 = min start_sp end_sp --the higher one will be removed
               | otherwise = 0 --no single op

--break condition: when no process left to be standardized           
standardize_h [] proc_std m_start state_s m_end state_e m_one ops_one
        = (reverse proc_std, m_start, reverse state_s, m_end, reverse state_e,
           m_one, reverse ops_one)

--removeMs removes patterns M1-M4 in a process
removeMs :: Process -> Process
removeMs = removeMs_h []

{-
The help-function removeMs_h goes through the operations of a process recursively.
In each round, it checks if the first four operations match any of the patterns
M1-M4. If that is the case, the operations are removed from the process and
memorized in the peak-op of the pattern. 
-}
removeMs_h :: Process -> Process -> Process
removeMs_h p_new p_old@(oi:oi1:oi2:oi3:rest)
        | matchM1 oi oi1 oi2 = removeMs_h p_new' p_old_matchM1
        | matchM2 oi oi1 oi2 = removeMs_h p_new' p_old_matchM2
        | matchM3 oi oi1 oi2 oi3 = removeMs_h p_new' p_old_matchM3
        | matchM4 oi oi1 oi2 oi3 = removeMs_h p_new' p_old_matchM4
        | otherwise = removeMs_h (oi:p_new) (oi1:oi2:oi3:rest) 
         where
         --calculate the new arguments for the next round. Since some ops might
         --have been removed, new patterns might appear. Therefor the scaning
         --has to continue at the position oi-2.
         p_new' = drop 2 p_new
         ops_return = reverse $ take 2 p_new
         --oi >= oi1 >= oi2
         p_old_matchM1 = let --get oi1's predecessor, oi1 it self, and its successors
                             ops_toAdd = getPred oi1 ++ [clearPredSucc oi1]
                                         ++ getSucc oi1
                             
                             --let oi memorize the above operations as its successors
                             oi' = addSucc oi ops_toAdd
                         in ops_return ++ (oi':oi2:oi3:rest)
         
         --oi <= oi1 <= oi2
         p_old_matchM2 = let ops_toAdd = getPred oi1 ++ [clearPredSucc oi1]
                                         ++ getSucc oi1
                             
                             --let oi2 memorize the above operations as its predecessors
                             oi2' = addPred oi2 ops_toAdd
                         in ops_return ++ (oi:oi2':oi3:rest)
         
         --oi is the peak in pattern M3
         p_old_matchM3 = let --get oi1's predecessor, oi1 itself, and its successors,
                             --oi2's prdecessor, oi2 itself, and its successors
                             ops_toAdd = getPred oi1 ++ [clearPredSucc oi1]
                                         ++ getSucc oi1 ++ getPred oi2
                                         ++ [clearPredSucc oi2] ++ getSucc oi2
                             
                             --let oi memorize the above operations as its successors
                             oi' = addSucc oi ops_toAdd
                         in ops_return ++ (oi':oi3:rest)
         
         --oi3 is the peak in pattern M4                
         p_old_matchM4 = let ops_toAdd = getPred oi1 ++ [clearPredSucc oi1]
                                         ++ getSucc oi1 ++ getPred oi2
                                         ++ [clearPredSucc oi2] ++ getSucc oi2
                             
                             --let oi3 memorize the above operations as its predecessors
                             oi3' = addPred oi3 ops_toAdd
                         in ops_return ++ (oi:oi3':rest)

--case that there are only three operations left to be checked.
removeMs_h p_new p_old@[oi,oi1,oi2]
        | matchM1 oi oi1 oi2 = removeMs_h p_new' p_old_matchM1
        | matchM2 oi oi1 oi2 = removeMs_h p_new' p_old_matchM2
        | otherwise = removeMs_h (oi:p_new) [oi1,oi2]
        where
         p_new' = (drop 2 p_new)
         ops_return = reverse $ take 2 p_new
         p_old_matchM1 = let ops_toAdd = getPred oi1 ++ [clearPredSucc oi1]
                                         ++ getSucc oi1
                             oi' = addSucc oi ops_toAdd
                         in ops_return ++ [oi',oi2]
         p_old_matchM2 = let ops_toAdd = getPred oi1 ++ [clearPredSucc oi1]
                                         ++ getSucc oi1
                             oi2' = addPred oi2 ops_toAdd
                         in ops_return ++ [oi,oi2']

--Break condition: there are less than three ops to be checked. No pattern can occur.
removeMs_h p_new p_old = (reverse p_new) ++ p_old

--help-functions for removeMs_h. Each checks if the operations in the arguments
-- match specific pattern and returns a bool.
matchM1 (Op _ _ sp1 _ _ _ _) (Op _ _ sp2 _ _ _ _)(Op _ _ sp3 _ _ _ _)
        = (sp1 >= sp2 && sp2 >= sp3)
        
matchM2 (Op _ _ sp1 _ _ _ _) (Op _ _ sp2 _ _ _ _)(Op _ _ sp3 _ _ _ _)
        = (sp1 <= sp2 && sp2 <= sp3)

matchM3 (Op _ _ sp1 _ _ _ _) (Op _ _ sp2 _ _ _ _)
        (Op _ _ sp3 _ _ _ _) (Op _ _ sp4 _ _ _ _)
        = (sp1 > sp2 && sp2 < sp3 && sp3 > sp4 && sp1 >= sp3 && sp2 >= sp4)

matchM4 (Op _ _ sp1 _ _ _ _) (Op _ _ sp2 _ _ _ _)
        (Op _ _ sp3 _ _ _ _) (Op _ _ sp4 _ _ _ _)
        = (sp1 < sp2 && sp2 > sp3 && sp3 < sp4 && sp1 <= sp3 && sp2 <= sp4)

----scan and its help-functions----
{-
The function scan heap-sorts operations (before the global valley) of
standardized processes by space increase between two neighboring operations
(a loacl valley and a local peak). It returns a tuple, which contains the minimal
space consumption of executing the processes and the corresponding schedul.
-}
scan:: [Process] -> [Operation]-> (Int, [[Operation]])  --(spmin, schedule)
scan procs valleys = let --initiate the heap
                         heap = toHeap procs
                         
                         --space of current state, which equals to the sum of space
                         --of the first op of all processes
                         s =  foldl (\x y -> x + (getSpace $ head y)) 0 procs
                         
                         --peak space consumption of the schedule
                         m = s
                         
                         --first state of the schedule, which consists of first
                         --op of all processes
                         first_state = map head procs
                         
                     in scan_h heap procs valleys s m [first_state]

{-help-function of scan. In each round, the min-element of the heap is omitted.
The corresponding process propagates by two operations (two states will be inserted
into the schedule; the space increase of the next two ops will be inserted into the
heap), if its global valley has not been met. The peak space of the schedule is
memorized during the recursion. The recursion stops, when the heap becomes empty
(all global valleys has been met).
--arguments: heap, processes, global valleys, space of current state, max. space
             ,schedule
--output: (max. Space, schedule)
-}
scan_h :: [(Int,Int)] -> [Process] -> [Operation] -> Int -> Int -> [[Operation]]
          -> (Int, [[Operation]])

scan_h (h:rest) procs valleys s m schedule
        = let --get the process id and space increase of the min-element of heap
              index_h = snd h 
              dist_h = fst h
              
              --get the process having the process id
              selected_proc = procs!!index_h
              
              --space usage and max. sapce usage for the next round
              s_new = if (not isGlobalValley)
                      then s + (getSpace (selected_proc !! 2)
                             - getSpace (selected_proc !! 0))
                      else s
              m_new = if (not isGlobalValley)
                      then max m (s + dist_h)
                      else m
              
              --processes for the next round. Only the process having the process
              --id might propagate (if its global valley has not been visited.
              procs' = map (\x -> if ((procs !! index_h) == x)
                                     && (not isGlobalValley)
                                  then drop 2 x else x) procs
              
              --The two operations of the min-element
              selected_ops = [selected_proc !! 2,selected_proc !! 1]
              
              --whether the global valley of the process having the process id is met
              isGlobalValley = valleys !! index_h `elem`
                               [selected_proc !! 0,selected_proc !! 1]
              
              --The first element of other processes
              ops_not_changed = [map head $ filter (\x -> procs!!index_h /= x) procs]
              
              --generate two states for schedule
              states = [Heap.sort(p:ps) | p <- selected_ops, ps <- ops_not_changed]
              
              --insert the states into the schedule, if the global vally of the 
              --propagating process has not been visted
              schedule_new = if not isGlobalValley
                             then states ++ schedule
                             else schedule
              
              --heap for the next round. If there are enough operations in the
              --propagating process and if the global valley has not been met,
              --insert a new element, which contains the space increase of the next
              --two operations of the process, into the heap and sort it.
              --If that is not the case, let the new heap be the old heap without
              --the min-element. 
              heap_new = if (length selected_proc >= 4) && (not isGlobalValley)
                         then let elem_new = ((getSpace(selected_proc!!3)
                                             - getSpace(selected_proc!!2)), index_h)
                              in Heap.sort $ elem_new:rest
                         else rest
          in scan_h heap_new procs' valleys s_new m_new schedule_new

--Break condition: the heap became empty. The schedule is complete.
scan_h [] procs valleys s m schedule = (m, reverse schedule)
         
{-
toHeap inserts the space increase of the first and second operations of all
processes into a list recursively and heap-sorts it.
-}
toHeap :: [Process] -> [(Int,Int)]
toHeap = Heap.sort . toHeap_h 0

toHeap_h :: Int -> [Process] -> [(Int,Int)]
toHeap_h _ [] = []
toHeap_h index (p:rest)=
        ((getSpace (p!!1) - getSpace (p!!0)),index):toHeap_h (index+1) rest
------------------------------------------------------------------------------------------------------------------
--some general help-functions

--functions for data type Operation
getPid (Op pid _ _ _ _ _ _) = pid
getOid (Op _ oid _ _ _ _ _) = oid
getSpace (Op _ _ sp _ _ _ _) = sp
getOps (Op _ _ _ ops _ _ _) = ops
getPred (Op _ _ _ _ _ pred _) = pred
getSucc (Op _ _ _ _ _ _ succ) = succ
--add sub-processes to an op
addSubPs (Op pid oid sp ops subps pred succ) subps' =
        (Op pid oid sp ops (subps ++ subps') pred succ)

addPred (Op pid oid sp ops ps pred succ) predToAdd =
        (Op pid oid sp ops ps (predToAdd ++ pred) succ)

addSucc (Op pid oid sp ops ps pred succ) succToAdd =
        (Op pid oid sp ops ps pred (succ ++ succToAdd))
        
clearPredSucc (Op pid oid sp ops ps pred succ) =
        (Op pid oid sp ops ps [] [])

--get-functions for 7er-tupel
fst_7 (x,_,_,_,_,_,_) = x
snd_7 (_,x,_,_,_,_,_) = x
third_7 (_,_,x,_,_,_,_) = x
forth_7 (_,_,_,x,_,_,_) = x
fifth_7 (_,_,_,_,x,_,_) = x
sixth_7 (_,_,_,_,_,x,_) = x
last_7 (_,_,_,_,_,_,x) = x


--print a list of anything that can be showed
print_list list = putStrLn $ toString_list list 
toString_list [] = ""
toString_list (x:rest) = (show x) ++ "\n\n" ++ toString_list rest

